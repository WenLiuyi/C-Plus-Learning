# 基本属性

## 1. 指针 & 引用:

### 1.1 区别

* 定义：指针是变量，存储指向的对象的地址；引用是变量的别名
  
* 级数：指针有多级；引用只有一级
  
* 初始化：指针可以为空，可以只声明不初始化（可以改变指向的对象）；引用非空，且**必须初始化**（必须绑定到一个对象，无法重新绑定）
  
* 参数传递：指针作为参数传递时，将实参的一个拷贝传递给形参，两者指向的地址相同，不是同一个变量，**函数中改变该指针的指向，不影响实参**
  
      void test(int *p){
          int a=1;
          p=&a;    // 函数体内的改变，不影响实参
      }
      int main(){
          int *p=NULL;
          test(p);    // p依旧为NULL
      }
  
* sizeof：指针得到本指针的大小；引用得到所指变量的大小
  

### 1.2 传递函数参数时的使用情景

* 使用指针：要返回函数局部变量的内存时（指针开辟内存，使用后释放，否则内存泄漏）
  
* 使用引用：对栈空间敏感（递归）；使用引用不创建临时变量，开销较小
  
* **类对象作为参数传递时**：使用引用
  

### 1.3 区别指针类型

    int *p[10]    // 指针数组，数组大小为10，每个元素是：指向int型的指针变量
    int (*p)[10]    // 数组指针：指向一个大小为10的int型数组
    int *p(int)    // 函数声明：返回值为int *类型
    int (*p)(int)    // 函数指针：指向的函数，具备int型参数，返回值为int类型

### 1.4 指针占用的字节

* 64位编译环境：指针占用8字节；32位环境：指针占用4字节
  
* **指针占用的内存：与编译环境有关，与机器位数无关**
  

### 1.5 strlen & sizeof：

* sizeof：运算符，**编译时确定**；strlen：库函数
  
* 参数：sizeof的参数可以是任何数据类型；strlen的参数只能是：字符指针，且结尾是'\0'的字符串
  
        int main(int argc, char const *argv[]){
            const char* str = "name";
      
            sizeof(str); // 取的是指针str的长度，是8
            strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
            return 0;
        }
  

## 2. 变量：声明，定义

### 2.1 声明 & 定义

> 背景：C++支持分离式编译，即将程序分割为若干个文件，每个文件可被**独立编译**

声明：使名字为程序所知，把变量的声明位置和类型提供给编译器，不分配内存空间。

定义：创造与名字关联的实体。

* 是否分配内存空间：声明不分配；定义分配
  
* 变量**可以在多处声明（外部变量extern），但只能定义一次**
  

## 3. const限定符

* const对象必须初始化
  
* 默认情况下，const对象被设定为仅在文件内有效（不同文件出现同名const变量时，等于在不同文件中，分别定义了独立变量）
  
* 对常量的引用（不能通过该引用，改变绑定对象的值）：
  
      const int ci=1024;
      const int &r1=ci;
      int &r2=ci;    // 错误：非常量引用，不能指向一个常量对象
  

### 3.1 常量指针 & 指向常量的指针

* 指向常量的指针：
  
  1. 对于常量，不能用普通指针指向，必须用指向常量的指针指向；
    
  2. 指向常量的指针，指向的对象可以为常量/非常量；
    
  3. **不能通过指向常量的指针，修改对象的值**。
    
  
      const double pi=3.14;    // 常量
      double *ptr=&ci;    // 错误：普通指针，不能指向常量
      const double *cptr=&pi;    // 正确
      *cptr=&pi;
  
* 常量指针：
  
  1. 指针本身是一个常量，不能改变指向对象（即存放在指针中的地址，也就是指向对象）；
    
  2. **必须初始化**；
    
  3. 可以通过常量指针，修改对象的值（如果对象是非常量）。
    

### 3.2 顶层const & 底层const

* 概念：
  
  顶层const（*右边）：const修饰的变量**本身**是一个常量，无法修改；
  
  底层const（*左边）：const修饰的变量**所指向的对象**是一个常量。
  
  * 用于声明引用的const，都是底层const
    
  
      int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
      const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
      const int b3 = 20; 		   //顶层const，b3是常量不可变
      const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
      const int& b5 = a;		   //用于声明引用变量，都是底层const
  
* 区分作用：
  
  * 执行对象拷贝时：常量的底层const，不能赋值给非常量的底层const；
    
  * 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const
    

## 4. 初始化

### 4.1 默认初始化

* 定义于任何函数体之外的变量：默认初始化为0
  
* **定义在函数体内部的内置类型变量**：不被初始化（其值未定义，拷贝/其他形式访问将引发错误）
  

### 4.2 拷贝初始化 & 直接初始化

* 用于**类类型对象时**：
  
  * 直接初始化：直接调用与实参匹配的构造函数
    
  * 拷贝初始化：调用拷贝构造函数：**使用指定构造函数创建一个临时对象，用拷贝构造函数将临时对象拷贝到正在创建的对象**
    
        string str1("I am a string");//语句1 直接初始化
        string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
        string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
        string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
    
* **为了提高效率，允许编译器跳过创建临时对象，直接调用构造函数创建对象，等价于直接初始化**：语句1，语句3等价
  
  * **拷贝构造函数为private**：语句3，4在编译时报错
    
  * 使用explit修饰构造函数：若构造函数存在隐式转换，编译时报错
    

### 4.3 初始化 & 赋值

* 对简单类型：初始化、赋值没有区别
  
* 对类/复杂数据类型，区别如下例：
  
      class A{
      public:
          int num1;
          int num2;
      public:
          A(int a=0, int b=0):num1(a),num2(b){};
          A(const A& a){};
          //重载 = 号操作符函数
          A& operator=(const A& a){
              num1 = a.num1 + 1;
              num2 = a.num2 + 1;
              return *this;
          };
      };
      int main(){
          A a(1,1);
          A a1 = a; //拷贝初始化操作，调用拷贝构造函数
          A b;
          b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
          return 0;
      }
  

## 5. auto类型说明符 & decltype类型指示符

### 5.1 auto

* 编译器，通过初始值，推断变量的类型
  
* 必须初始化
  
* auto一般忽略顶层const（本身为常量），保留底层cosnt（指向对象为常量）
  
      const int ci=i;    // 顶层const
      auto b=ci;    // b是一个整数（顶层const属性被忽略）
      const auto c=ci;    // 需要指明
  

### 5.2 decltype

1. decltype(variable)：若单层括号内是一个变量，返回该变量的类型；
  
2. decltype((variable))：双层括号，将其当成一个表达式，返回的结果一定是引用
  
3. decaltype(f())：并不实际调用函数f，而是返回：假如f被调用，将会返回的那个类型
  

    int i;
    decltype ((i)) d;    // 错误：d是int &，必须初始化
    decltype (i) e;    // 正确：e是一个未初始化的int
