# 字符串、向量和数组

## 1. 标准库类型string

string：可变长的字符序列

* 初始化：直接初始化 & 拷贝初始化

* string对象上的操作：
  
  * getline读取一整行：从给定输入流读入内容，直至遇到换行符为止（换行符也会被读入）
    
    ```c++
    int main(){
        string line;
        while(getline(cin,line) cout<<line<<endl;
        return 0;
    }
    ```

* size_type：无符号整数

* string比较：按字典序（大小写敏感），靠后的字符更大

* string和字面值相加：每个“+”两侧的运算对象，至少有一个是string

### 1.1 string对象中的字符

使用库：#include<cctype>

* 使用for语句改变字符串中的字符：需要**把循环变量定义为引用类型**
  
  ```c++
  for(auto &c:s) c=toupper(c);
  ```

## 2. 标准库类型vector

* vector是类模板，能容纳绝大多数类型的对象作为元素，但元素不能为引用（引用不是对象）

```c++
vector<int> v1(10);    // 圆括号（构造vector对象）：v1有10个元素，每个元素的值为0
vector<int>v2{10};    // 花括号（列表初始化）
```

* 判断相等：v1==v2，当且仅当：元素数量相同、对应位置的元素值相同

* 判断关系：按字典序

* 下标形式可用于访问已存在的元素，不能用于添加元素
  
  

## 3. 迭代器

* begin：返回指向第一个元素的迭代器；end返回指向容器**尾元素的下一位置**的迭代器
  
  * 若容器为空，则begin和end返回同一个迭代器：尾后迭代器

```c++
auto b=v.begin(),e=v.end();
```

> 泛型编程：
> 
> 1. 使用迭代器而非下标：迭代器在标准库提供的所有容器上有效
> 
> 2. 使用==或!=而非<,>：所有标准库容器的迭代器都定义了==和!=

* 迭代器类型：
  iterator能读写元素；const_iterator只能读取、不能修改所指的元素值（可使用cbegin，cend）
  
  ```c++
  vector<int>::iterator it;
  string::iterator it2;
  `vector<int>::const_iterator it3;`
  string::const_iterator it4;
  ```

* 某些对vector的操作，将使得迭代器失效：
  
  1. 不能在for循环内，向vector对象添加元素；
  
  2. **任何改变vector对象容量的操作（比如push_back），会使得vector对象的迭代器失效。**

* 迭代器的距离：string和vector都定义了带符号整型数**difference_type**（两个迭代器必须：合法、指向同一个容器的元素）
  
  

## 4. 数组

* 定义时**必须指定数组类型，不能用auto关键字**；

* 不能使用一个数组，为另一个数组整体初始化/赋值。

* ```c++
  int (*Parray)[10]=&arr;    // 数组指针：Parray指向一个含有10个整数的数组
  `int (&arrRef)[10]=arr; // 数组引用：arrRef引用一个含有10个整数的数组`
  ```

### 4.1 访问数组元素

* 数组下标：通常定义为size_t（无符号类型）

### 4.2 指针和数组

* 使用**取地址符：获取指向某个对象的指针**
  
  * 用到数组名字时：编译器自动将其替换为：一个指向数组首元素的指针；
  
  * 当使用数组作为一个auto变量的初始值时：推断得到指针而非数组
  
  * 当使用decltype时：推断得到数组
  
  ```c++
  string nums[]={"one","two","three"};
  string *p=&nums[0];    // p指向nums的第一个元素
  string *p2=nums;    // 等价于：string *p=&nums[0];
  
  int ia[]={0,1,2,3};
  auto ia2(ia);    // ia2是一个整型指针，指向ia的第一个元素
  auto ia2(&ia[0]);
  
  decltype(ia) ia3={0,1,2,3};
  ia3[4]=i;
  ```

* 指针也是迭代器：`int *e=&arr[10];`// 指向arr尾元素的下一位置的指针
  
  > 注意：尾后指针不能执行：解引用、递增

* begin, end：指向数组首元素、尾元素下一位置的指针
  
  ```c++
  int ia[]={0,1,2,3};
  int *beg=begin(ia),*last=end(ia);
  ```

* 两个指针相减的类型：**ptrdiff_t**（带符号类型）

### 4.3 C风格字符串

* 比较字符串：C语言中，不能直接比较（直接比较的时指向数组首元素的指针，而非字符串本身），需要用`strcmp`函数
  
  ```c
  if(strcmp(ca1,ca2)<0)    // 和两个string对象的比较s1<s2结果一样：前面的字符串较大，返回正值
  ```

* 字符串相加：C语言中，使用`strcpy`和`strcat`函数

### 4.4 使用数组初始化vector对象

* 不能使用数组/vector初始化/赋值数组；但可以使用数组初始化vector
  
  ```c++
  int int_arr[]={0,1,2,3,4,5};
  vector<int>ivec(begin(int_arr),end(int_arr));
  vector<int>subVec(int_arr+1,int_arr+4);
  ```

### 4.5 使用for语句处理多为数组

* 除了最内层循环外，所有循环的控制变量，都应该是引用类型（若要改变最内层循环中的元素值，控制变量也应该是引用类型）：避免数组被自动转换为指针
  
  ```c++
  for(const auto &row:ia){
      for(auto col:row){
      
      }
  }
  ```

### 4.6 指针和多维数组

* 使用多维数组的名字时：自动转换为**指向第一个内层数组的指针**
  
  ```c++
  int ia[3][4];
  int (*p)[4]=ia;    // p指向：含有4个整数的数组
  p=&ia[2];    // p指向ia的尾元素
  ```

* 使用auto或decltype：
  
  ```c++
  for(auto p=ia;p!=ia+3;++p){
      for(auto q=*p;q!=*p+4;++q){
  }
  }
  ```

* 使用begin和end：
  
  ```c++
  for(auto p=begin(ia);p!=end(ia);++p){
      for(auto q=begin(*p);q!=end(*p);++q){
  }
  }
  ```
