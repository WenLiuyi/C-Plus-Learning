# 函数

## 1. 函数基础

* 函数调用：用实参初始化函数对应的形参；将控制权转移给被调用的函数

### 1.1 局部对象

* **名字有作用域；对象有生命周期**
  
  * 名字作用域：程序文本的一部分
  
  * 对象生命周期：该对象存在的**一段时间**

* **局部变量**：形参、函数内部定义的变量（仅在函数作用域可见）

* **自动对象**：**只存在于块执行期间的对象**
  
  * 形参是一种自动对象：函数开始时，为形参申请存储空间；函数终止时，形参销毁
  
  * 内置类型的未初始化变量，将产生未定义的值

* **局部静态对象 static类型**：**程序执行路径第一次经过对象定义语句时初始化；程序终止时才被销毁（对象所在函数结束执行也不影响）**
  
  

### 1.2 函数声明（函数原型）

* 函数三要素：返回类型，函数名，形参类型

* 变量可以声明多次，只能定义一次；

* 函数可以只有声明，没有定义（如果永远不用到）

* **把函数声明放在头文件**：确保同一函数的所有声明保持一致
  
  

### 1.3 分离式编译

* 源文件-(编译)->目标文件-(链接)->可执行文件
  
  

## 2. 参数传递

### 2.1 传值参数

* 传递**非引用类型**的形参时：**将实参的值拷贝给形参（形参、实参是两个相互独立的对象）**
  
  * 函数对形参的操作，不影响实参

* **指针形参**：**拷贝的是指针的值（拷贝后，两个指针是不同的指针）**
  
  ```c++
  void reset(int *ip){
      *ip=0;    // 改变指针ip所指对象的值
      ip=0;    // 只改变指针ip的局部拷贝，未改变实参
  }
  
  int i=42; 
  reset(&i); // 改变i的值，而非i的地址（改变在函数体内部的局部拷贝，不会改变实参）
  ```

### 2.2 传引用参数

* 传递**引用类型**参数：**绑定到对应的实参上（即引用所引的对象）**

* 使用引用避免拷贝：

* 例：string比较长，所以一般使用引用（函数内部不修改引用参数的值时，最好声明为：常量引用）
  
  ```c++
  bool func(const string &s){}
  ```

* 传入一个额外的引用实参，用于返回额外信息
  
  

### 2.3 const形参和实参

* 用实参初始化形参时，忽略顶层const，例如：
  
  ```c++
  void func(const int i){}
  void func(int i){}    // 相当于完全一样的定义
  ```
  
  > 1. 指针和所指对象的类型必须保持一致。
  >    例外：允许一个指向常量的指针，指向非常量对象（但不允许一个普通指针，指向常量对象）
  > 
  > 2. 可以用字面值初始化常量引用，不能初始化非常量引用。
  > 
  > ```c++
  > const double pi=3.14;
  > double *ptr=π    // 错误：普通指针不可以指向常量对象
  > double dval=3,14;
  > const double *cptr=&dval;    // 正确：指向常量的指针，可以指向非常量对象
  > ```

* 参数传递的初始化规则，和引用/指针的相同：
  
  ```c++
  int i=0;
  const int ci=i;
  
  reset(&i);    // 正确
  reset(&ci);    // 错误：不能用指向const int对象的指针，初始化int *
  reset(ci);    // 错误：不能把普通引用，绑定至const对象ci上
  reset(42);    // 错误：不能把普通引用，绑定到字面值上
  ```

* 定义形参时，尽量使用常量引用，否则容易出现以下问题：
  
  1. 误导调用者，即函数可以修改实参的值；（如果函数体内不能修改，最好定义为常量引用）
  
  2. 无法将const对象、字面值、需要类型转换的对象，传递给普通的引用形参。（否则编译错误）
     
     

### 2.4 数组形参

* 传递的是：指向数组首元素的指针

```c++
void print(const int *);
void print(const int []);
void print(const int[10]);
// 以上每个都有一个const int *类型的形参
```

* 数组引用形参：
  
  ```c++
  f(int &arr[10]);    // 错误：这是引用的数组
  f(int (&arr)[10]);    // 正确：arr是具备10个整型的整型数组的引用
  ```

* 传递多维数组：
  形参是指向含有10个整数的数组的指针
  
  ```c++
  void print(int matrix[][10], int rowSize){}
  ```

#### 2.4.1 含有可变形参的函数

##### initializer_list形参（标准库类型）

* 适用于：实参数量未知，全部实参类型相同
  
  ```c++
  initializer_list<T> lst;
  lst2(lst);    // 不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素
  lst.begin();lst.end();
  ```

* initializer_list对象中元素永远是常量值，无法改变其中元素的值。

##### 省略符形参

void foo(param_list, ...)

* 省略符形参只能出现在形参列表的最后一个位置

* param_list的实参会执行正常的类型检查；省略符对应实参无需类型检查
  
  

## 3. 返回类型，return语句

* 不要返回局部对象的引用/指针：函数完成后，所占用存储空间被释放

* 可以为返回类型是非常量引用的函数结果赋值
  
  ```c++
  char *get_val(...) {}
  get_val(...)='A';
  ```

* 列表初始化返回值（返回花括号包围的值得列表）
  
  ```c++
  vector<string> process(){
      return {"str1","str2"};
  }
  ```

* main函数可以没有return语句（编译器在结尾隐式插入一条返回0的return语句）
  
  * `EXIT_FAILURE`,`EXIT_SUCCESS`是预处理变量
  
  ```c++
  #include<cstdlib>
  int main(){
      if(any_failure) return EXIT_FAILURE;
      ekse return EXIT_SUCCESS;
  }
  ```

### 3.1 返回数组指针

#### 3.1.1 使用类型别名

```c++
typedef int arrT[10];
using arrT=int[10];
arrT *func(int i);
```

#### 3.1.2 声明一个返回数组指针的函数

* 形参列表先于数组维度
  
  ```c++
  Type (*function(param_list)) [dimension]
  int (*func(int i))[10];
  ```

#### 3.1.3 使用尾置返回类型

```c++
auto func(int i)->int(*)[10]
```



## 4. 函数重载

* **同一作用域，几个函数名字相同，形参列表不同**
  
  * main函数不能重载

* 重载忽略顶层const，考虑底层const
  
  ```c++
  Record lookup(Phone);
  Record lookup(const Phone);    // 顶层const，重复声明
  
  
  Record lookup(Phone *);
  Record lookup(Phone *const);    // 顶层const，重复声明
  
  
  Record lookup(Account&);
  Record lookup(const Account&);    // 新函数，底层const
  
  
  Record lookup(Account *);
  Record lookup(const Account *);    // 新函数，作用于指向常量的指针
  ```

> 显式转换(强制类型转换）：cast-name<type>(expression)
> 
> * static_cast：不包含底层const的，都可以使用static_const
>   
>   1. 将较大算术类型，赋值给较小的类型
> 
> * const_cast：去掉底层const，不能改变类型（但是将常量转为非常量对象后，可以获得写权限）
>   
>   * 但是：若对象非常量，使用const_cast获得写权限是合法行为；
>   
>   * 若对象是常量，使用const_cast执行写操作，产生未定义后果
>     
>     ```c++
>     const chat *pc;
>     char *p=const_cast<char *>(pc);    // 正确：但通过p写值是未定义行为
>     ```

* 调用重载函数：进行函数匹配（重载确定），可能有三种结果：
  
  * 编译器找到实参的**最佳匹配**；
  
  * 找不到匹配，编译器发出**无匹配**错误信息；
  
  * 有多于一个函数匹配，发生**二义性调用**



## 5. 函数其他特性

* 局部变量，不作为默认实参

## 5.1 内联函数，constexpr函数

* 内联函数（inline）：将其在每个调用点上内联地展开
  
  * 用于：优化规模小、流程直接、频繁调用的函数；降低函数调用的开销

* constexpr函数：用于**常量表达式**的函数
  
  * 函数的**返回值类型、形参类型都是字面值类型**；函数中，有且仅有一条return语句

### 5.2 调试帮助

* assert预处理宏

* NDEBUG预处理变量（关闭调试状态）
